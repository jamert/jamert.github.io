---
layout: post
title: On Updatable Views
subtitle: Fat model, skinny controller
tags:
  - python
  - postgresql
---

In database courses they tell you that your data should lie in normalized tables with
foreign keys all the way down. But as application developer you want somehow to get your
data back in one semantically meaningful lump. One way is to use ORM that will write
your queries for you provided that you describe all polygamous relationships between
tables using fancy ORM syntax. I can list actual downsides for this, but it really
boils down for me to one thing: I'd rather invest in learning SQL really good, than
learning ORM really good. Other way is to make some views, and if you must implement not
only 'R' in 'CRUD' then your view should be updatable. I like second approach because
this is only one I can implement (TODO: write more authoritative reason). I am going to
use Python, PosgreSQL and SQLAlchemy with psycopg2 and present some example of updatable views
in action.


## Specification

Let's say, I am B2B 'Rent' company providing SaaS thingy of kinds 'Basement', 'Dugout' and 'Castle'
each of which can be provided under SLA with levels 'normal' or 'vip'. Also, I want to have
each client to have autogenerated numerical ID, because it would be nice to provide some ID to client,
and in that process not to show him that he is our second or third client.

I think I want to get data for each client in the following form, where `services` is a list of
tuples `(service, sla)` for each client:

{% highlight text %}
 id  |      name       |     services       |          registered
-----+-----------------+--------------------+-------------------------------
 542 | Enterprise inc. | {"(basement,vip)"} | 2015-06-29 16:33:42.258203+00
{% endhighlight %}


## Implementation

Let's write database schema to hold our data.

{% highlight sql %}
{% include on-updatable-views/normalized-schema.sql %}
{% endhighlight %}

Here we'll implement additional layer of abstractions in form of updatable view. 'Updatable' part is provided
by triggers. You can use rules for this purpose, but I wouldn't recommend it just for the reason of lessening
mental load on yourself because triggers can do all the things on which rules are capable of and more.

{% highlight sql %}
{% include on-updatable-views/updatable-view.sql %}
{% endhighlight %}

Our view now supports all modifying operations.

Let's fill our tables with some test data and make sure
our view is working as expected.

{% highlight sql %}
{% include on-updatable-views/test-data.sql %}
{% endhighlight %}

Our python code will be much more straightforward and simple due
to massive SQL line count.

{% highlight python %}
{% include on-updatable-views/test_view.py %}
{% endhighlight %}

